<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WC2019菜鸡游记]]></title>
    <url>%2F2019%2F01%2F30%2FWC2019%2F</url>
    <content type="text"><![CDATA[前面的讲课非常的易懂，非常的不让人自闭，你甚至可以在WC2019上听量子计算 比赛题非常的好，一道传统题，一道题答题，一道交互题 由于我的电脑出现了某来自CCF的神秘力量，我的noi linux上面的操作栏没了，输入法还改不了，终端甚至要暴力枚举出快捷键打开，于是狗牌滚粗 社会活动非常的不好玩，不去竟然要惩罚 太菜了，不讲了 PS：今年的CCF和选手都很咕呢，果然咕的机构会教出咕的选手 PPS：闭幕式上dzd表示我们要[数据删除]]]></content>
  </entry>
  <entry>
    <title><![CDATA[模板库]]></title>
    <url>%2F2019%2F01%2F23%2F%E6%A8%A1%E6%9D%BF%E5%BA%93%2F</url>
    <content type="text"><![CDATA[菜鸡的模板库。。。有些代码没跑过，如有错请大佬们指出，蒟蒻会虚心接受的（滑稽滑稽）数论 BSGS以及扩展BSGS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#define ll long long//BSGSmap&lt;int,int&gt;Hash;int BSGS(int x,int y)&#123; x%=P,y%=P; if(y==1)return 0; if(!x&amp;&amp;!y)return 1; if(!x)return -1; Hash.clear(); int M=ceil(sqrt(P)),val=1,k=1; for(int i=0;i&lt;M;++i)&#123; Hash[1ll*val*y%P]=i; val=1ll*val*x%P; &#125; for(int i=M;;i+=M)&#123; k=1ll*k*val%P; int T=(Hash.find(k)==Hash.end())?-1:Hash[k]; if(T!=-1)return i-T; if(i&gt;P)break; &#125; return -1;&#125;//扩展BSGSll exbsgs(ll A,ll B,ll P)&#123; A%=P,B%=P; if(B==1)return 0; if(!A&amp;&amp;!B)return 1; if(!A)return -1; ll cnt=0,K=1,d; while((d=gcd(A,P))!=1)&#123; if(B%d)return -1; cnt++; B/=d,P/=d; K=K*(A/d)%P; if(B==K)return cnt; &#125; ll M=ceil(sqrt(P)); Hash.clear(); ll val=1; for(ll i=0;i&lt;M;++i)&#123; Hash[val*B%P]=i; val=val*A%P; &#125; for(ll i=M;;i+=M)&#123; K=K*val%P; int T=(Hash.find(K)==Hash.end())?-1:Hash[K]; if(T!=-1)return i-T+cnt; if(i&gt;P)break; &#125; return -1;&#125; XXX变换(FFT&amp;NTT&amp;FWT)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define ll long long//系统FFT////原始#define pi acos(-1)void FFT(complex&lt;double&gt;*T,int len,int ty)&#123; complex&lt;double&gt;unit,mul,x,y; int i,j,k,m; for(i=0;i&lt;len;++i)&#123; for(j=0,k=i,m=len-1;m&gt;0;j=(j&lt;&lt;1)|(k&amp;1),k&gt;&gt;=1,m&gt;&gt;=1); if(i&lt;j)x=T[i],T[i]=T[j],T[j]=x; &#125; for(m=1;m&lt;len;m&lt;&lt;=1)&#123; unit=exp(complex&lt;double&gt;(0,ty*pi/(double)(m))); for(i=0;i&lt;len;i+=(m&lt;&lt;1))&#123; mul=1; for(j=0;j&lt;m;++j)&#123; x=T[i+j],y=T[i+j+m]*mul; T[i+j]=x+y,T[i+j+m]=x-y; mul*=unit; &#125; &#125; &#125; if(ty==1)return; for(int i=0;i&lt;len;++i)T[i]=T[i]/len;&#125;////优化struct cpx&#123; double x,y; cpx()&#123;&#125; cpx(double xx, double yy)&#123;x=xx,y=yy;&#125; friend cpx operator *(cpx a,cpx b)&#123;return cpx(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125; friend cpx operator /(cpx a,double b)&#123;return cpx(a.x/b,a.y/b);&#125; friend cpx operator +(cpx a,cpx b)&#123;return cpx(a.x+b.x,a.y+b.y);&#125; friend cpx operator -(cpx a,cpx b)&#123;return cpx(a.x-b.x,a.y-b.y);&#125; friend cpx operator *(cpx a,double b)&#123;return cpx(a.x*b,a.y*b);&#125;&#125;;void BT()&#123; int len=N+M+1; Len=1,L=0; while(Len&lt;len)Len&lt;&lt;=1,L++; for(int i=0;i&lt;Len;++i)rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1|(i&amp;1)&lt;&lt;(L-1));&#125;void FFT(cpx *T,int len,int ty)&#123; cpx unit,mul,x,y; for(int i=0;i&lt;len;++i)if(i&lt;rev[i])swap(T[i],T[rev[i]]); for(int m=1;m&lt;len;m&lt;&lt;=1)&#123; unit=cpx(cos(pi/m),ty*sin(pi/m)); for(int i=0;i&lt;len;i+=(m&lt;&lt;1))&#123; mul=cpx(1,0); for(int j=0;j&lt;m;++j)&#123; x=T[i+j],y=mul*T[i+j+m]; T[i+j]=x+y,T[i+j+m]=x-y; mul=mul*unit; &#125; &#125; &#125; if(ty==1)return; for(int i=0;i&lt;len;++i)T[i]=T[i]/len;&#125; 1234567891011121314151617181920212223242526272829303132333435//NTT////原始#define P 998244353#defien G 3ll ksm(ll a,ll b)&#123; ll ret=1; while(b)&#123; if(b&amp;1)ret=ret*a%P; a=a*a%P,b&gt;&gt;=1; &#125; return ret;&#125;void NTT(ll *T,int len,int ty)&#123; int unit,mul,x,y; int i,j,k,m; for(i=0;i&lt;len;++i)&#123; for(j=0,k=i,m=len-1;m&gt;0;j=(j&lt;&lt;1)|(k&amp;1),k&gt;&gt;=1,m&gt;&gt;=1); if(i&lt;j)x=T[i],T[i]=T[j],T[j]=x; &#125; for(m=1;m&lt;len;m&lt;&lt;=1)&#123; unit=ksm(G,(P-1+ty*(P-1)/(m&lt;&lt;1))%(P-1)); for(i=0;i&lt;len;i+=(m&lt;&lt;1))&#123; mul=1; for(j=0;j&lt;m;++j)&#123; x=T[i+j],y=T[i+j+m]*mul%P; T[i+j]=(x+y)%P,T[i+j+m]=((x-y)%P+P)%P; mul=mul*unit%P; &#125; &#125; &#125; if(ty==1)return; ll t=ksm(len,P-2); for(int i=0;i&lt;len;++i)T[i]=T[i]*t%P;&#125;//拆系数NTT（找不到代码了） 1//FWT（到时候吧QAQ） 高斯消元123456789101112131415//高斯消元void gauss()&#123; for(int i=1;i&lt;=N;++i)&#123; int x=i; while(!Map[x][i]&amp;&amp;x&lt;=N)x++; if(x&gt;N)return 0; if(x!=i)for(int j=i;j&lt;=N;++j)swap(Map[i][j],Map[x][j]); int inv=ksm(Map[i][i],P-2); for(int j=i+1;j&lt;=N;++j)&#123; if(!Map[j][i])continue; int mul=Map[j][i]*inv%P; for(int k=i;k&lt;=N;++k)Map[j][k]=(Map[j][k]-Map[i][k]*mul%P+P)%P; &#125; &#125;&#125; 行列式12345678910111213141516171819202122//行列式int gauss()&#123;//去掉1行1列的余子式 int ans=1,cnt=0; for(int i=2;i&lt;=N;++i)&#123; int x=i; while(!Map[x][i]&amp;&amp;x&lt;=N)x++; if(x&gt;N)return 0; if(x!=i)&#123; cnt^=1; for(int j=i;j&lt;=N;++j)swap(Map[i][j],Map[x][j]); &#125; ans=ans*Map[i][i]%P; int inv=ksm(Map[i][i],P-2); for(int j=i+1;j&lt;=N;++j)&#123; if(!Map[j][i])continue; int mul=Map[j][i]*inv%P; for(int k=i;k&lt;=N;++k)Map[j][k]=(Map[j][k]-Map[i][k]*mul%P+P)%P; &#125; &#125; if(cnt)ans=(P-ans)%P; return ans;&#125; 线性基1234567891011121314151617//线性基struct LB&#123; ll v[65]; void add(ll x)&#123; for(int i=61;i&gt;=0;--i)&#123; if(x&amp;(1ll&lt;&lt;i))&#123; if(!v[i])&#123;v[i]=x;break;&#125; x^=v[i]; &#125; &#125; &#125; ll getmax()&#123; ll ret=0; for(int i=61;i&gt;=0;--i)ret=max(ret,ret^v[i]); return ret; &#125;&#125; 图论 网络流(sap&amp;dinic&amp;zkw)1234567891011121314151617181920//sapll sap(int u,ll flow)&#123;//注意编号从1开始(我太菜了QWQ) if(u==T||!flow)return flow; ll sum=0,tmp; for(int i=Last[u],v;i;i=Next[i])&#123; v=End[i]; if(Len[i]&amp;&amp;dis[u]==dis[v]+1)&#123; tmp=sap(v,min(Len[i],flow-sum)); Len[i]-=tmp,Len[i^1]+=tmp; sum+=tmp; if(sum==flow||dis[S]&gt;=T+1)return sum; &#125; &#125; if(dis[S]&gt;=T+1)return sum; cnt[dis[u]]--; if(!cnt[dis[u]])dis[S]=T+1; dis[u]++; cnt[dis[u]]++; return sum;&#125; 1234567891011121314151617181920212223242526272829303132333435//dinicbool findpath()&#123; for(int i=0;i&lt;=Cnt;++i)dis[i]=-1; queue&lt;int&gt;Q; dis[S]=0,Q.push(S); while(Q.size())&#123; int u=Q.front(); Q.pop(); for(int i=Last[u],v;i;i=Next[i])&#123; v=End[i]; if(Flow[i]&amp;&amp;(!~dis[v]))&#123; dis[v]=dis[u]+1,Q.push(v); if(v==T)return 1; &#125; &#125; &#125; return 0;&#125;int dinic(int u,int flow)&#123; if(u==T)return flow; int sum=0,tmp; for(int i=Last[u],v;i;i=Next[i])&#123; v=End[i]; if(Flow[i]&amp;&amp;dis[v]==dis[u]+1)&#123; tmp=dinic(v,min(flow-sum,Flow[i])); sum+=tmp,Flow[i]-=tmp,Flow[i^1]+=tmp; if(sum==flow)return sum; &#125; &#125; if(!sum)dis[u]=-1; return sum;&#125;void maxflow()&#123; while(findpath())Maxflow+=dinic(S,inf);&#125; 123456789101112131415161718192021222324252627282930313233int aug(int u,int flow)&#123; if(u==T)&#123; Mincost+=-dis[S]*flow,Maxflow+=flow; return flow; &#125; vis[u]=1; int sum=0,tmp; for(int i=Last[u],v;i;i=Next[i])&#123; v=End[i]; if(Flow[i]&amp;&amp;!vis[v]&amp;&amp;dis[u]-dis[v]+Cost[i]==0)&#123; tmp=aug(v,min(flow-sum,Flow[i])); sum+=tmp; Flow[i]-=tmp,Flow[i^1]+=tmp; if(sum==flow)return sum; &#125; &#125; return sum;&#125;bool mdf()&#123; int u,v,d=inf; for(int i=2;i&lt;=o;++i)&#123; if(Flow[i]&amp;&amp;vis[u=St[i]]&amp;&amp;!vis[v=End[i]])d=min(d,dis[u]-dis[v]+Cost[i]); &#125; if(d==inf)return 0; for(int i=S;i&lt;=T;++i)if(vis[i])dis[i]-=d; return 1;&#125;void zkw()&#123; do&#123; for(int i=S;i&lt;=T;++i)vis[i]=0; aug(S,inf); &#125;while(mdf());&#125; Tarjan12345678910111213141516171819202122//Tarjanvoid tarjan(int u)&#123; vis[u]=1,st.push(u); dfn[u]=low[u]=++vt; for(int i=Last[u],v;i;i=Next[i])&#123; v=End[i]; if(!dfn[v])&#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(vis[v])low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u])&#123; suc++; int tmp=0; while(tmp!=u)&#123; tmp=st.top(); vis[tmp]=0,st.pop(); bel[tmp]=suc; &#125; &#125;&#125; Kruskal重构树123456789101112131415161718192021222324//Kruskal重构树struct edge&#123;//NOI2018 归程 int u,v,len,hight; bool operator&lt;(const edge &amp;x)const&#123; return hight&gt;x.hight; &#125;&#125;E[maxn];int find(int x)&#123; return (x==fa[x])?x:fa[x]=find(fa[x]);&#125;void kl()&#123; sort(E+1,E+1+M); for(int i=1;i&lt;=N;++i)fa[i]=i; cnt=N; for(int i=1,tot=0;i&lt;=M;++i)&#123; int U=find(E[i].u),V=find(E[i].v); if(U!=V)&#123; val[++cnt]=E[i].hight; fa[cnt]=cnt,fa[U]=fa[V]=cnt; ins(cnt,U,0),ins(cnt,V,0); if(++tot==N-1)break; &#125; &#125;&#125; 字符串 Manacher123456789101112131415161718192021//Manachervoid init()&#123; H[0]=-1,H[1]=0,Len=2; for(int i=1;i&lt;=N;++i)&#123; scanf("%d",H[Len]); Len++,H[Len]=0,Len++; &#125; H[Len]=-2;&#125;int Manacher()&#123; int ret=-1; int Pos; for(int i=1;i&lt;Len;++i)&#123; if(i&lt;Max)R[i]=min(R[2*Pos-i],Max-i+1); else R[i]=1; while(H[i-R[i]]==H[i+R[i]])R[i]++; if(Max&lt;i+R[i]-1)Max=i+R[i]-1,Pos=i; ret=max(ret,R[i]-1); &#125; return ret;&#125; KMP12345678910111213141516171819202122//KMPvoid KMP()&#123; scanf("%s",A+1); scanf("%s",B+1); int lenA=strlen(A+1); int lenB=strlen(B+1); int j=0; for(int i=2;i&lt;=lenB;++i)&#123; while(j&amp;&amp;B[j+1]!=B[i])j=fail[j]; if(B[j+1]==B[i])j++; fail[i]=j; &#125; j=0; for(int i=1;i&lt;=lenA;++i)&#123; while(j&gt;0&amp;&amp;B[j+1]!=A[i])j=fail[j]; if(B[j+1]==A[i])j++; if(j==lenB)&#123; //xxx j=fail[j]; &#125; &#125;&#125; 自动机(AC自动机&amp;后缀自动机)1234567891011121314151617181920212223242526//AC自动机namespace ACAM&#123;//滑稽 int ch[maxn&lt;&lt;1][26],fail[maxn&lt;&lt;1],tot; void extend()&#123; scanf("%s",s+1); int p=0,t,len=strlen(s+1); for(int i=1;i&lt;=len;++i)&#123; t=s[i]-'a'; if(!ch[p][t])ch[p][t]=++tot; p=ch[p][t]; &#125; //xxx &#125; void getfail()&#123; queue&lt;int&gt;Q; for(int t=0;t&lt;26;++t)if(ch[0][t])Q.push(ch[0][t]); while(Q.size())&#123; int x=Q.front(); Q.pop(); for(int t=0;t&lt;26;++t)&#123; if(ch[x][i])Q.push(ch[x][i]),fail[ch[x][i]]=ch[fail[x]][i]; else ch[x][i]=ch[fail[x]][i]; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223//后缀自动机namespace SAM&#123; map&lt;ll,int&gt;ch[maxn&lt;&lt;1]; int par[maxn&lt;&lt;1],mx[maxn&lt;&lt;1]; int tot,las; void init()&#123; for(int i=1;i&lt;=tot;++i)ch[i].clear(),mx[i]=par[i]=0; las=tot=1; &#125; void extend(ll c)&#123; int p=las,np=++tot; mx[np]=mx[p]+1; for(;p&amp;&amp;(!ch[p].count(c));p=par[p])ch[p][c]=np; las=np; if(!p)&#123;par[np]=1;return;&#125; int q=ch[p][c]; if(mx[q]==mx[p]+1)&#123;par[np]=q;return;&#125; int nq=++tot; ch[nq]=ch[q],mx[nq]=mx[p]+1,par[nq]=par[q]; par[q]=par[np]=nq; for(;p&amp;&amp;ch[p].count(c)&amp;&amp;ch[p][c]==q;p=par[p])ch[p][c]=nq; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4663 Hack]]></title>
    <url>%2F2018%2F12%2F21%2Fbzoj4663%20Hack%2F</url>
    <content type="text"><![CDATA[传送门%%%Newuser，直接秒掉了一句话题意：割掉一些边使得S，T之间不连通且S-&gt;T的路径上仅有一条割边考试题 首先看题面和数据范围，就可以知道跟最小割有关。 普通的最小割可以实现前一半，那么如何处理后一半呢？ 先放一张样例 直接跑最小割答案是2，即切掉1-&gt;3,2-&gt;4 但我们发现，那S-&gt;2-&gt;4-&gt;1-&gt;3-&gt;T这条路径上就有两条割边了 那么想让这种情况不成立，即使得这个割不是个割==&gt;使得S，T连通 我们可以连一条1-&gt;4的边使得S，T联通 为了防止这条边被割，我们把这条边的容量变为inf即可 那么我们可以给每条边连一条反向的容量为inf的边 因为最小割是所有正向割边的权值和，所以就算加边时加入了反向边，这种边被割了也不会对答案造成影响。 由于容量为inf，所以只会在其他方案都不成立时割这条边，那么答案若大于inf就输出-1 你以为完了？？？再来看这个图 显然答案为2，只要割掉S-&gt;T就行了 但用上面的方法跑出来是7 为什么？ 仔细一想，反向边虽然不影响答案，但会使得有些一开始不存在的S-&gt;T的路径存在，如S-&gt;1-&gt;T 那么一开始先把图连好，把S不能到的点标记了，再往网络流里加边。 因为到不了，所以跟到不了的点连的边自然也不用加入网络流了 于是你就A掉了此题 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;stdio.h&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt; #define inf 0x3f3f3f3f3f3fll#define ll long long#define maxn 10005using namespace std;int N,M;int S,T;int Last[maxn],Next[maxn],End[maxn],o=1;int U[maxn],V[maxn];ll W[maxn];vector&lt;int&gt;G[maxn];bool mark[maxn];ll Len[maxn];ll dis[maxn];int cnt[maxn];void ins(int a,int b,ll c)&#123; Next[++o]=Last[a],Last[a]=o; End[o]=b,Len[o]=c;&#125;void inss(int a,int b,ll c)&#123; ins(a,b,c),ins(b,a,0);&#125;ll sap(int u,ll flow)&#123; if(u==T||!flow)return flow; ll sum=0,tmp; for(int i=Last[u],v;i;i=Next[i])&#123; v=End[i]; if(Len[i]&amp;&amp;dis[u]==dis[v]+1)&#123; tmp=sap(v,min(Len[i],flow-sum)); Len[i]-=tmp,Len[i^1]+=tmp; sum+=tmp; if(sum==flow||dis[S]&gt;=T)return sum; &#125; &#125; if(dis[S]&gt;=T)return sum; cnt[dis[u]]--; if(!cnt[dis[u]])dis[S]=T; dis[u]++; cnt[dis[u]]++; return sum;&#125;bool vis[maxn];void dfs(int u)&#123; vis[u]=1; for(int i=0,v;i&lt;G[u].size();++i)&#123; v=G[u][i]; if(!vis[v])dfs(v); &#125;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); S=1,T=N; for(int i=1;i&lt;=M;++i)&#123; scanf("%d%d%lld",&amp;U[i],&amp;V[i],&amp;W[i]); U[i]++,V[i]++; G[U[i]].push_back(V[i]); &#125; dfs(S); for(int i=1;i&lt;=M;++i)&#123; if(!vis[U[i]]||!vis[V[i]])continue; inss(U[i],V[i],W[i]); inss(V[i],U[i],inf); &#125; ll ret=0; while(dis[S]&lt;T)&#123; ret+=sap(S,inf); if(ret&gt;=inf)&#123; printf("-1"); return 0; &#125; &#125; printf("%lld",ret); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[震惊！！！某一liu姓男子竟然在ACM赛上做出这种事[点击展开]]]></title>
    <url>%2F2018%2F12%2F08%2F%E9%87%8D%E4%BA%A4ACM%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[%%%OBlack，Newuser，hdhd差点AK虐场（听说被卡常了233） （分别是高三最强，高二最强，高一最强） 上午报了到就去吃午饭，重交食堂竟然把所有菜混在一起。。。太冷了不说了 下午12：40开考，考前在楼下闲逛 考前立了个flag，说图论，网络流都给我，结果就遭重了 拿到题，分到了C题，给你一个序列$f(i)=a * f(i-2)+b * f(i-1) $，每次操作往x序列$[l,r]$上分别加上$f(1),f(2)……f(r-l+1)$。 想起了原来做过的加斐波那契数列的题，于是直接差分 cf(l)+=f(1)\\ cf(l+1)-=b*f(1)\\ cf(l+1)+=f(2)\\ cf(r+1)+=f(r-l+2)\\ cf(r+2)+=a*f(r-l+1)\\然后算最后的数组时记下i-1，i-2位的值X，Y然后乘加乘加之类的就行了 然而打代码时石乐志，把最后的*a写成了*b，送了一发WA PS：我一开始打不来对拍真是太菜了 然后把ABCDF做完后刚H题，光想着反悔堆了，殊不知网络流可以完美解决 我考试时还奶了一口，这题不会是图论吧233不可能的吧 然后成功奶中，白坐了一个小时。。。 PSS：这告诉我们没事不要乱插旗（逃 PSSS：陶陶摘苹果这个队名真是太政治正确了 没什么好说的，我的降智buff太强了，只有第六，被上面三位大佬吊锤]]></content>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2017-树状数组]]></title>
    <url>%2F2018%2F11%2F28%2F%5BZjoi2017%5D%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[传送门：Zjoi2017-树状数组吐槽：听说被分到了最简单的题。。。体节：我一看，题目中的Find操作像是求后缀异或和，然后打打表发现就是后缀异或和QAQ 那么对于Query(l,r)，Right=XOR（l，r）（l-&gt;r的数异或和），Now=XOR（l-1，r-1）。 显然答案是否正确只跟l-1，r的修改次数之和的奇偶性有关，那么我们只需要维护对于每个查询的点对被修改成偶数次的概率就行了。。。 对于Modify（l，r），若（L，R）与（l，r）相交，那么（L，R）这个点对被修改的概率即为$\frac{1}{r-l+1}$。若被覆盖，被修改的概率即为$\frac{2}{r-l+1}$。 那么思路就比较清晰了，以l建外层线段树，以r建内层线段树，矩阵修改（三次），单点查询。因为是线段树上区间操作，而这又是树套树，所以直接下放lazy的复杂度是不对的，我们要用永久化标记，单点查询就是合并一下到根路径上的永久化标记就行了。 但是注意了，还有一个特殊情况没有考虑，就是Query（l，r）时l==1的时候。 此时，Right=XOR（1，r），Now=Find（r）-Find（l-1）=Find（r）-Find（0）=Find（r）=XOR（r，N） 这样的话特判一下，再开个线段树单独维护前缀异或和==后缀异或和的概率就行了 这里介绍一个巧妙的方法（%%%wxh） Now=XOR（r，N）=XOR（1，N）$\otimes$XOR（1，r-1） 而XOR（1，N）就是总修改次数啊，直接用个cnt就行了 那么特殊情况转换为cnt为奇数时，输出r修改次数为奇数的概率；cnt为偶数时，输出r修改次数为偶数的概率，可以直接用（0，r）这个点对的概率得到 至于修改次数为偶数的概率的合并，无非是$P_{奇} * P_{奇}+P_{偶} * P_{偶}$，然后转换为%998244353意义下就行了 简短的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define ll long long#define inf 0x3f3f3f3f#define P 998244353#define maxn 200005using namespace std;int N,M;int ls[maxn*400],rs[maxn*400],tot;int W[maxn*400];//和为奇数的概率int rt[maxn&lt;&lt;4];int ksm(int a,int b) &#123; int ret=1; while(b) &#123; if(b&amp;1)ret=1ll*ret*a%P; b&gt;&gt;=1,a=1ll*a*a%P; &#125; return ret;&#125;int merge(int a,int b) &#123; return (1ll*a*(P+1-b)+1ll*b*(P+1-a))%P;&#125;void modify(int &amp;p,int l,int r,int y1,int y2,int D) &#123; if(!p)p=++tot; if(y1&lt;=l&amp;&amp;y2&gt;=r) &#123; W[p]=merge(W[p],D); return; &#125; int mid=l+r&gt;&gt;1; if(y1&lt;=mid&amp;&amp;y2&gt;=l)modify(ls[p],l,mid,y1,y2,D); if(y2&gt;=mid+1&amp;&amp;y1&lt;=r)modify(rs[p],mid+1,r,y1,y2,D);&#125;void Modify(int p,int l,int r,int x1,int x2,int y1,int y2,int D) &#123; if(x1&lt;=l&amp;&amp;x2&gt;=r) &#123; modify(rt[p],0,N,y1,y2,D); return; &#125; int mid=l+r&gt;&gt;1; if(x1&lt;=mid&amp;&amp;x2&gt;=l)Modify(p&lt;&lt;1,l,mid,x1,x2,y1,y2,D); if(x2&gt;=mid+1&amp;&amp;x1&lt;=r)Modify(p&lt;&lt;1|1,mid+1,r,x1,x2,y1,y2,D);&#125;int query(int p,int l,int r,int y) &#123; if(!p)return 0; if(l==r)return W[p]; int mid=l+r&gt;&gt;1; int ret=W[p]; if(y&lt;=mid)ret=merge(ret,query(ls[p],l,mid,y)); else ret=merge(ret,query(rs[p],mid+1,r,y)); return ret;&#125;int Query(int p,int l,int r,int x,int y) &#123; if(l==r)return query(rt[p],0,N,y); int mid=l+r&gt;&gt;1; int ret=query(rt[p],0,N,y); if(x&lt;=mid)ret=merge(ret,Query(p&lt;&lt;1,l,mid,x,y)); else ret=merge(ret,Query(p&lt;&lt;1|1,mid+1,r,x,y)); return ret;&#125;int main() &#123; scanf("%d%d",&amp;N,&amp;M); int opt,x,y; int cnt=0; for(int i=1; i&lt;=M; ++i) &#123; scanf("%d%d%d",&amp;opt,&amp;x,&amp;y); int inv=ksm(y-x+1,P-2); if(opt==1) &#123; Modify(1,0,N,x,y,x,y,1ll*2*inv%P); Modify(1,0,N,0,x-1,x,y,inv); Modify(1,0,N,x,y,y+1,N,inv); cnt++; &#125; if(opt==2) &#123; if(x==1&amp;&amp;(cnt&amp;1))printf("%d\n",Query(1,0,N,x-1,y)); else printf("%d\n",(P+1-Query(1,0,N,x-1,y))%P); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018滚粗记]]></title>
    <url>%2F2018%2F11%2F12%2FNOIP2018%E6%BB%9A%E7%B2%97%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Day 0去bs试机，见了鬼的键盘啊，空格左右悬空，回车则硬的一笔，摁不下去。。。 Day1听说是原题？？？然而并没做过。。。T1随手敲了个会被卡成 $N^2$ 的假分治。。。，随机极限数据后就不管了（我一定是脑抽了）T2一眼没看出是背包，于是写了个同余系BFS判断当前数是否能被表示（反正不会T，然而空间开小了一些）T3二分+贪心骗分啊。。。（一定是lg数据太水了竟然骗了95）期望：100+100+95（如果被卡：70+90+？） Day 2昨天水题今天神题？？？T1写了个堆然后光荣的wa完了基环树的点（我好像还过完了大样例的233）T2找规律啊。。。结果失智了啊，N==2的规律是 $3^{M-1} * 4 $ 。。。结果硬生生被我写成了组合数*2的幂。。。（反正结果一样）T3什么东西，只会$N^2$树形DP验证啊。。。然而，我SB调前面调了太久，打T3时太急了，一直过不了样例，只能爆0期望：60+45+0。。。是不是省一无望了啊 送给学长们的话： 一个个OIer的竞赛生涯总是从一场NOIP开始，大多也在一场NOIP中结束，好似一次次轮回在不断上演。如果这次NOIP是你的起点，那么祝你的OI生涯如同夏花般绚烂。如果这次NOIP是你的终点，那么祝你的OI回忆宛若繁星般璀璨。]]></content>
  </entry>
  <entry>
    <title><![CDATA[扩展BSGS]]></title>
    <url>%2F2018%2F11%2F06%2F%E6%89%A9%E5%B1%95BSGS%2F</url>
    <content type="text"><![CDATA[先看这样一个性质: 若A≡B(mod P) 假设d=gcd(A,P)，且B%d=0 则 $\frac{A}{d}$ ≡$\frac{B}{d}$(mod $\frac{P}{d}$) 所以只要B%d==0,就能一直化简直到d=gcd(A,P)=1 我们再来$a^x$ ≡b(mod P) 如果也能这样化简的话就能直接用BSGS做了 显然如果化简过程中B%d!=0，那么就无解 于是原方程可以写为$A^{x-cnt}​$ * $\frac{A^{cnt}}{S}​$≡$\frac{B}{S}​$(mod $\frac{P}{S}​$) ( S=d1* d2* d3 * … *dcnt) 换元，$A^{‘}$ ≡ $\frac{A^{x-cnt}}{S}$，$B^{‘}$≡$\frac{B}{S}$ ，$P^{‘}$≡$\frac{P}{S}$ 此时 $P^{‘}$ 为质数，就用BSGS处理 1234567891011121314151617181920212223242526272829ll exbsgs(ll A,ll B,ll P)&#123; A%=P,B%=P; if(B==1)return 0; if(!A&amp;&amp;!B)return 1; if(!A)return -1; ll cnt=0; ll K=1; ll d; while((d=gcd(A,P))!=1)&#123; if(B%d)return -1; cnt++; B/=d,P/=d; K=K*(A/d)%P; if(B==K)return cnt; &#125; ll M=ceil(sqrt(P)); Hash.clear(); ll val=1; for(ll i=0;i&lt;M;++i)&#123; Hash[val*B%P]=i; val=val*A%P; &#125; for(ll i=M;;i+=M)&#123; K=K*val%P; if(Hash.count(K))return i-Hash[K]+cnt; if(i&gt;P)break; &#125; return -1;&#125; PSS：用map存可能会TLE（？？？）所以最好用哈希表]]></content>
  </entry>
  <entry>
    <title><![CDATA[铁路运输]]></title>
    <url>%2F2018%2F10%2F31%2F%E9%93%81%E8%B7%AF%E8%BF%90%E8%BE%93%2F</url>
    <content type="text"><![CDATA[铁路运费 (train.pas/c/cpp)吐槽：今天摸你赛好颓啊。。。【问题描述】 CSSYZ 国有 N 个城市，依次编号为 1, 2, …, N。城市 1 是 CSSYZ 国的首都。该国的铁路公司只有1家，由FYT垄断经营，FYT公司运营着M条路线。路线被编号为1, 2, …M，第 i 条线路(1&lt;=i&lt;=M)双向连接着城市 Ui和城市 Vi。城市间的移动方式只有铁路。任意两个城市之间都能通过若干条铁路互通，即任意两个城市之间，直接连接的路线最多只有 1 条；对于任一城市，从该市总是可以通过若干条路线到达城市 1。 现在所有路线的运费都是 1 元。陷于经营困境的 FYT 计划在今后 Q 年间提高若干条路线的运费。在这个计划里，第 j 年(1&lt;=j&lt;=Q)的年初将把路线 Rj的运费从 1 元提升到2 元。被提价过一次的路线的运费将一直是 2 元，不会再次提价。此外，FYT 的铁路公司每年还会调查每个城市的市民的满意度。计划开始前，每个城市的市民都表示满意，但提价之后，可能会出现表示不满的市民。每年的满意度调查都在当年的提价完成之后进行。所以进行第 j 年(1&lt;=j&lt;=Q)的满意度调查时，路线 R1, R2, …, Rj的运费提升已经完成，此外的路线还没有被提价。第 j 年的满意度调查里，如果城市 k(2&lt;=k&lt;=N)的市民从城市 k 到首都城市 1 的费用的最小值比计划开始前的最小费用要高，则会对铁路公司表示不满。 如果路线经过多条铁路，费用是各条路线的运费的和。城市 1 的市民不会对铁路公司表示不满。另外请注意，提价后获得最小费用要使用的路线可能跟计划开始前的不一样。在整个计划开始之前，对于今后 Q 年间市民的满意度调查，FYT 希望计算存在不满市民的城市个数。请写出一个程序，给定 CSSYZ 国的铁路路线信息和提价计划，输出每次满意度调查里存在不满市民的城市个数。 【输入】 第一行为 3 个用空格隔开的整数 N, M, Q。N 为城市个数，M 为路线条数，Q 为提价计划的执行年数。 接下来 M 行中第 i 行(1&lt;=i&lt;=M)为两个用空格隔开的整数 Ui, Vi，表示第 i 条路线连接着城市 Ui和 Vi。 接下来 Q 行中第 j 行(1&lt;=j&lt;=Q)为整数 Rj，表示计划的第 j 年将提升路线 Rj的运费。 【输出】输出 Q 行，第 j 行(1&lt;=j&lt;=Q)表示第 j 年的满意度调查中存在不满市民的城市个数。 【输入输出样例1】1234567891011125 6 51 21 34 23 22 55 352413 1234502244 【输入输出样例2】123456789101112134 6 61 21 31 42 32 43 4142536 123456112233 【数据范围】 25%的数据满足：N&lt;=100，M&lt;=4 950，Q&lt;=30； 50%的数据满足：Q&lt;=30；75%的数据满足：输出结果里出现的不同数最多50种； 100%的数据满足：2 ≦ N ≦ 100 000，1 ≦ Q ≦ M ≦ 200 000，1 ≦ Ui ≦ N， 1 ≦ Vi ≦ N，Ui != Vi ，1 ≦ Rj ≦ M，Rj != Rk (1 ≦ j &lt; k ≦ Q） 题解。。。（膜拜hdhd）由于当时我在颓。。。没仔细想啊我太弱了把原图改为只有1到各点为最短路的图，于是改边权可变为删边（具体原理，用心体会）于是最后查询时，若这条边的点入度为零就删点，因为此时这个点到1不是最短路，所以ans++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//丢个代码溜了呀，再次膜拜hdhd#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;queue&gt;#define ll long long#define inf 0x3f3f3f3f#define maxn 100005using namespace std;int N,M,Q;int Last[maxn],Next[maxn&lt;&lt;2],End[maxn&lt;&lt;2],o=1;int dis[maxn];int belong[maxn&lt;&lt;1],id[maxn&lt;&lt;1];int du[maxn];vector&lt;int&gt;G[maxn];bool del[maxn];int ans;queue&lt;int&gt;Qu;void ins(int a,int b)&#123; End[++o]=b; Next[o]=Last[a]; Last[a]=o;&#125;void inss(int a,int b)&#123; ins(a,b),ins(b,a);&#125;void Del(int u)&#123; if(del[u])return; del[u]=1; ans++; for(int i=0,v;i&lt;G[u].size();++i)&#123; v=G[u][i]; if(v&lt;0)continue; --du[v]; G[u][i]=-1; if(!du[v])Del(v); &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;N,&amp;M,&amp;Q); int a,b; for(int i=1;i&lt;=M;++i)&#123; scanf("%d%d",&amp;a,&amp;b),inss(a,b); &#125; for(int i=2;i&lt;=N;++i)dis[i]=inf; Qu.push(1); while(Qu.size())&#123; int u=Qu.front(); Qu.pop(); for(int i=Last[u],v;i;i=Next[i])&#123; v=End[i]; if(dis[v]&gt;dis[u]+1)&#123; dis[v]=dis[u]+1; Qu.push(v); &#125; &#125; &#125; for(int u=1;u&lt;=N;++u)&#123; for(int i=Last[u],v;i;i=Next[i])&#123; v=End[i]; if(dis[v]==dis[u]+1)&#123; ++du[v]; belong[i&gt;&gt;1]=u; id[i&gt;&gt;1]=G[u].size(); G[u].push_back(v); &#125; &#125; &#125; int tmp; while(Q--)&#123; scanf("%d",&amp;tmp); if(!belong[tmp])&#123;//不在最短路中 printf("%d\n",ans); continue; &#125; int u=belong[tmp],v=G[u][id[tmp]]; if(v&lt;0)&#123;//边删了 printf("%d\n",ans); continue; &#125; G[u][id[tmp]]=-1; --du[v]; if(!du[v])Del(v);//若入度为零就删点，此时这个点到1不是最短路即ans++ printf("%d\n",ans); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[同余系BFS]]></title>
    <url>%2F2018%2F10%2F29%2F%E5%90%8C%E4%BD%99%E7%B1%BBBFS%2F</url>
    <content type="text"><![CDATA[题目链接：P3403 跳楼机题目意思：给定x,y,z,H,求x,y,z由加法能得到的H以内的数的个数。体节 ：乍一看是个数论，心里一想，不对~~~~于是蒟蒻只能去学了一发同余系BFS（%%%Newuser大佬）那这题就成了模板啦！设x为x,y,z最小的，在模x意义下，由i-&gt;(i+y)%x，权值为y；由i-&gt;(i+z)%x，权值为z。最后跑一遍最短路或BFS，求出dis[i],那么dis[i]+k*x都能取到，于是此题得解。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#define ll long long#define maxn 100005using namespace std;ll H;int P[4];ll dis[maxn];bool vis[maxn];int Last[maxn],Next[maxn&lt;&lt;1],End[maxn&lt;&lt;1],Len[maxn&lt;&lt;1],o;void ins(int a,int b,int c)&#123; End[++o]=b; Next[o]=Last[a]; Last[a]=o; Len[o]=c;&#125;void spfa(int x)&#123; queue&lt;int&gt;Q; memset(dis,0x3f,sizeof(dis)); dis[x]=1; vis[x]=1; Q.push(x); while(Q.size())&#123; int u=Q.front(); Q.pop(); vis[u]=0; for(int i=Last[u],v;i;i=Next[i])&#123; v=End[i]; if(dis[u]+Len[i]&lt;dis[v])&#123; dis[v]=dis[u]+Len[i]; if(!vis[v])&#123; vis[v]=1; Q.push(v); &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%lld%d%d%d",&amp;H,&amp;P[1],&amp;P[2],&amp;P[3]); sort(P+1,P+3); if(P[1]==1)&#123; printf("%lld",H); return 0; &#125; for(int i=0;i&lt;P[1];++i)&#123; int pos2=(i+P[2])%P[1]; int pos3=(i+P[3])%P[1]; ins(i,pos2,P[2]),ins(i,pos3,P[3]); &#125; spfa(1); ll ans=0; for(int i=0;i&lt;P[1];++i)&#123; if(dis[i]&lt;=H)&#123; ans+=(H-dis[i])/P[1]+1; &#125; &#125; printf("%lld",ans); return 0;&#125; NOIP来了，看似慌得一笔实际慌得一笔，只有%大佬们才能攒人品呢。 123while(1)&#123; if(%hdhd&amp;&amp;%PHD&amp;&amp;%Newuser&amp;&amp;%Washington)RP++;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ZROJ2018D6T1--萌新拆塔]]></title>
    <url>%2F2018%2F08%2F10%2FZROJ2018D6T1-%E8%90%8C%E6%96%B0%E6%8B%86%E5%A1%94%2F</url>
    <content type="text"><![CDATA[传送门：ZROJ2018D6T1—萌新拆塔注：杜老师出题~~~题面： 作为一场自闭模拟赛，需要一道10k模拟加玄学剪枝题。 在魔塔这个游戏中，勇士有四个数值，血量，攻击，防御和魔防。怪物也有三个数值，血量，攻击和防御。勇士和怪物攻击方式一般是这样的，双方轮流攻击，每回合造成自己攻击减去对方防御的伤害，如果自己的攻击比对方的防御低，那么无法对对方造成伤害。如果怪物血量变得小于等于0，那么怪物死亡，勇士获胜。如果勇士的攻击不超过怪物的防御，那么无法战斗。在一场战斗后，如果怪兽造成的总伤害超过了自己的魔防，那么消耗的血量为总伤害减去自己的魔防值，否则伤害为0。勇士必须保证战斗之后剩余的血量大于0。 一般来说，都是勇士先攻击。但是怪物有一些特殊属性： 先攻：第一个回合由怪物先攻击。 魔攻：怪物会无视勇士的防御，你可以认为在战斗的时候勇士的防御为0。 二连击：怪物每回合攻击两次。 模仿：怪物的攻防与勇士的攻防相同。 这四个特殊属性都是可以任意叠加的。 这个魔塔里面有n个怪，每个怪后面都守着一个宝石，每个宝石都能对血量，攻击，防御和魔防这些数值有所增益。同时打怪之间有一些先后顺序，比如说如果怪v被怪u挡住了，那么我们只能先打u再打v。所以我们会有k条规则，表示u这个怪必须在v之前打。 你可以需要按一定顺序去清怪和吃宝石，吃宝石之前要求守着这个宝石的怪被杀死。 请问杀完所有的怪剩下的最多能剩多少血量。 输入格式: 第一行一个整数T，表示数据组数。 每组数据第一行四个整数，表示$h,a,d,m$，表示勇士的初始血量，攻击，防御与魔防。$(1≤h≤10^9,1≤a,d≤10^5,0≤m≤10^5)$ 接下来一行一个数字n，表示怪的数量。 接下来n行，每行八个数字，表示$H,A,D,S,ap,dp,mp,hp$，表示怪物的血量，攻击，防御，属性，以及怪物守的宝石能增加的攻击，防御，魔防和血量。 $(1≤H,A,D≤10^5,0≤S≤15,0≤ap,dp,mp≤10^4,1≤hp≤10^9)$ 怪物的属性由二进制表示，如果有先攻属性，那么S增加1，魔攻增加2，二连击增加4，模仿增加8。 接下来一行一个整数k，表示有k条规则。接下来k行，每行两个正整数$u,v(1≤u&lt;v≤n)$，表示怪u必须在怪v之前杀死。 输出格式 对于每组数据输出一行，表示杀完所有的怪剩下的最多血量。如果无法清完所有怪，那么输出−1。 样例: 样例输入:120 2 2 0102 2 0 0 2 0 0 8018 8 0 0 0 0 0 2040 6 1 0 2 0 0 4042 7 3 0 1 0 0 4010 10 5 0 0 2 0 4025 5 0 0 0 0 0 2035 4 1 0 0 1 0 2060 7 2 0 1 1 0 4032 8 2 0 0 0 0 60160 15 0 0 0 0 0 091 22 31 44 51 66 76 87 94 10 样例输出:-1 限制与规定： 对于 20% 的数据，有 1≤n≤5,k=0，所有怪物没有特殊属性。 对于 40% 的数据，有 1≤n≤8,k=0，所有怪物没有特殊属性。 对于另外 20% 的数据，有 1≤n≤14,k≤100，所有怪物没有特殊属性。 对于另外 20% 的数据，有 1≤n≤8,k≤100。 对于 100% 的数据，有 1≤n≤14,k≤100,T≤10。 时间限制：10s 空间限制：512MB 解释： 关于魔防可以认为打完一个怪总伤害会减去魔防的值，也可以理解成每次打怪前你有一个血量为魔防值的护盾，怪物会优先扣护盾的血量。 比如说你的攻击是15，防御是5，魔防是7，怪物血量是20，攻击是20，防御是5，没有特殊属性。 那么你可以在2轮杀死怪物，怪物会攻击你1轮。你打这个怪受到的伤害为max(15−7,0)。 你每次可以选择打一个不违反限制的怪或者吃一个不违反限制的宝石。 样例1只要按顺序打怪并且吃宝石即可。 两个人轮流攻击，我们记A为勇士，B为怪物。 那么先攻的攻击顺序为BABABA… 二连击的攻击顺序为ABBABBABB… 吐槽&amp;题解： 古老的魔塔游戏2333 跟10k大模拟没有毛线关系（不愧是传说中的毒瘤出题人） 三进制状压。。。（看到数据范围想到二进制状压emmm） 第i位为0表示没打第i位怪，1表示打了怪没吃水晶（Q：为什么会不吃水晶呢？A：因为有模仿怪呀！），2表示打了怪吃了水晶。 因为答案是要求最大血量，那么我们就用f[i]来表示i这个状态最大的血量，然后预处理出各个状态的攻击，防御，魔防。 转移的话，第i只怪的位置如果要从0-&gt;1，则先判断在这只怪之前必打的怪打了没有，然后如果S（S为以当前状态k的属性打这个怪后的血量）大于要更新的状态$f[k+3^{i-1}]$，那就更新。 而如果要从1-&gt;2，则只要$f[k+3^{i-1}]=max(f[k+3^{i-1}],f[k]+hp[i])$,因为其它属性已经预处理好了。 至于打怪操作和怪的特殊属性，大力模拟就好了。。。 贴个代码。。。暴力都打不来的我真是太弱了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//三进制状压 0-&gt;没打 1-&gt;打了没吃 2-&gt;打了吃了 #include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#define ll long long#define maxn 15#define maxx 4783970using namespace std;int A,D;ll H;int N,M,T,K;int h[maxn],a[maxn],d[maxn],s[maxn];int ph[maxn],pa[maxn],pd[maxn],pm[maxn];int mi[maxn];int fa[maxx],fd[maxx],fm[maxx];ll f[maxx];vector&lt;int&gt;Pre[maxn];void ins(int a,int b)&#123; Pre[a].push_back(b);&#125;ll beat(ll H,int A,int D,int M,int h,int a,int d,int s)&#123; if(s&amp;8)a=A,d=D; if(s&amp;2)D=0; int o=1+((s&gt;&gt;2)&amp;1); int X=max(0,a-D)*o;//怪伤 int x=max(0,A-d);//人伤 if(x==0)return 0; ll S=1ll*((h-1)/x+1-(~s&amp;1))*X; if(S&gt;H+M)return 0; if(S&gt;M)H=H-(S-M); return H;&#125;int main()&#123; mi[0]=1; for(int i=1;i&lt;15;++i)mi[i]=mi[i-1]+(mi[i-1]&lt;&lt;1); scanf("%d",&amp;T); while(T--)&#123; scanf("%lld%d%d%d",&amp;H,&amp;A,&amp;D,&amp;M); scanf("%d",&amp;N); // for(int i=1;i&lt;=N;++i)Pre[i].clear(); memset(f,0,sizeof(f)); f[0]=H; // for(int i=1;i&lt;=N;++i)&#123; scanf("%d%d%d%d",&amp;h[i],&amp;a[i],&amp;d[i],&amp;s[i]); scanf("%d%d%d%d",&amp;pa[i],&amp;pd[i],&amp;pm[i],&amp;ph[i]); &#125; scanf("%d",&amp;K); int u,v; for(int i=1;i&lt;=K;++i)&#123; scanf("%d%d",&amp;u,&amp;v); ins(v,u);//*** &#125; int tot=mi[N]-1; for(int k=0;k&lt;=tot;++k)&#123; fa[k]=A,fd[k]=D,fm[k]=M; for(int i=1;i&lt;=N;++i)&#123; if(k/mi[i-1]%3==2)&#123; fa[k]+=pa[i],fd[k]+=pd[i],fm[k]+=pm[i]; &#125; &#125; &#125; for(int k=0;k&lt;=tot;++k)&#123; if(!f[k])continue; for(int i=1;i&lt;=N;++i)&#123; if(k/mi[i-1]%3==0)&#123; bool bz=0; for(int j=0;j&lt;Pre[i].size();++j)&#123; if(k/mi[Pre[i][j]-1]%3==0)&#123; bz=1; break; &#125; &#125; if(bz)continue; ll S=beat(f[k],fa[k],fd[k],fm[k],h[i],a[i],d[i],s[i]); if(S&gt;0)f[k+mi[i-1]]=max(f[k+mi[i-1]],S); &#125; else&#123; if(k/mi[i-1]%3==1)&#123; f[k+mi[i-1]]=max(f[k+mi[i-1]],f[k]+ph[i]); &#125; &#125; &#125; &#125; if(f[tot]==0)printf("-1\n"); else printf("%lld\n",f[tot]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[POJ3764--The xor-longest Path]]></title>
    <url>%2F2018%2F08%2F03%2FPOJ3764%2F</url>
    <content type="text"><![CDATA[传送门：POJ3764—The xor-longest Path题目大意:在一颗带权的树上，求任意两点间路径上各边权值异或和的最大值。题目解法：设dis(u,v)为u,v间路径上各边权值异或和。显然dis(u,v)==dis(root,u)^dis(root,v),所以问题转换为求任意两个点i,j到root的路径上各边权值异或和最大。于是我们用dfs预处理，把每个dis(root,i)丢进一个二进制trie中。那每丢一个dis(root,i)，显然要在trie中找能使尽量多的二进制位与dis(root,i)相反，这样才能使这两个的异或和最大，这其实就是个贪心。真相は一つしかない: 正解就是trie+贪心（逃 嗯♂~~~代码实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#define ll long long#define maxn 100005using namespace std;int N;int _last[maxn],_next[maxn&lt;&lt;1],_end[maxn&lt;&lt;1],_len[maxn&lt;&lt;1];int val[maxn];int o;int tot;void ins(int a,int b,int c)&#123; _end[++o]=b; _next[o]=_last[a]; _last[a]=o; _len[o]=c;&#125;void inss(int a,int b,int c)&#123; ins(a,b,c); ins(b,a,c);&#125;struct node&#123; int son[2]; void init()&#123; son[0]=son[1]=0; &#125;&#125;;node tri[4000005];void dfs(int u,int fa)&#123; for(int i=_last[u];i;i=_next[i])&#123; int v=_end[i]; if(v==fa)continue; val[v]=val[u]^_len[i]; dfs(v,u); &#125;&#125;void add(int x)&#123; int p=0; int o=0; for(int i=30;i&gt;=0;--i)&#123; if(x&amp;(1&lt;&lt;i))o=1; else o=0; if(!tri[p].son[o])&#123; tri[p].son[o]=++tot; tri[tot].init(); &#125; p=tri[p].son[o]; &#125;&#125;int gs(int x)&#123; int num=0,p=0,o=0; for(int i=30;i&gt;=0;--i)&#123; if(x&amp;(1&lt;&lt;i))o=0; else o=1; if(tri[p].son[o])&#123; num|=(1&lt;&lt;i); p=tri[p].son[o]; &#125; else p=tri[p].son[o^1]; &#125; return num;&#125;int main()&#123; while(scanf("%d",&amp;N)!=EOF)&#123; for(int i=1;i&lt;=o;++i)_last[i]=0; o=0; tot=0; tri[tot].init(); val[1]=0; int u,v,w; for(int i=1;i&lt;N;++i) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); ++u; ++v; inss(u,v,w); &#125; dfs(1,0); int ans=0; for(int i=1;i&lt;=N;++i)&#123; ans=max(ans,gs(val[i])); add(val[i]); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello world!!!]]></title>
    <url>%2F2018%2F07%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[啊♂，终于搞好了,可以搞事了（嘿嘿嘿）]]></content>
  </entry>
</search>
