<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ZROJ2018D6T1--萌新拆塔]]></title>
    <url>%2F2018%2F08%2F10%2FZROJ2018D6T1-%E8%90%8C%E6%96%B0%E6%8B%86%E5%A1%94%2F</url>
    <content type="text"><![CDATA[传送门：ZROJ2018D6T1—萌新拆塔注：杜老师出题~~~题面： 作为一场自闭模拟赛，需要一道10k模拟加玄学剪枝题。 在魔塔这个游戏中，勇士有四个数值，血量，攻击，防御和魔防。怪物也有三个数值，血量，攻击和防御。勇士和怪物攻击方式一般是这样的，双方轮流攻击，每回合造成自己攻击减去对方防御的伤害，如果自己的攻击比对方的防御低，那么无法对对方造成伤害。如果怪物血量变得小于等于0，那么怪物死亡，勇士获胜。如果勇士的攻击不超过怪物的防御，那么无法战斗。在一场战斗后，如果怪兽造成的总伤害超过了自己的魔防，那么消耗的血量为总伤害减去自己的魔防值，否则伤害为0。勇士必须保证战斗之后剩余的血量大于0。 一般来说，都是勇士先攻击。但是怪物有一些特殊属性： 先攻：第一个回合由怪物先攻击。 魔攻：怪物会无视勇士的防御，你可以认为在战斗的时候勇士的防御为0。 二连击：怪物每回合攻击两次。 模仿：怪物的攻防与勇士的攻防相同。 这四个特殊属性都是可以任意叠加的。 这个魔塔里面有n个怪，每个怪后面都守着一个宝石，每个宝石都能对血量，攻击，防御和魔防这些数值有所增益。同时打怪之间有一些先后顺序，比如说如果怪v被怪u挡住了，那么我们只能先打u再打v。所以我们会有k条规则，表示u这个怪必须在v之前打。 你可以需要按一定顺序去清怪和吃宝石，吃宝石之前要求守着这个宝石的怪被杀死。 请问杀完所有的怪剩下的最多能剩多少血量。 输入格式: 第一行一个整数T，表示数据组数。 每组数据第一行四个整数，表示$h,a,d,m$，表示勇士的初始血量，攻击，防御与魔防。$(1≤h≤10^9,1≤a,d≤10^5,0≤m≤10^5)$ 接下来一行一个数字n，表示怪的数量。 接下来n行，每行八个数字，表示$H,A,D,S,ap,dp,mp,hp$，表示怪物的血量，攻击，防御，属性，以及怪物守的宝石能增加的攻击，防御，魔防和血量。 $(1≤H,A,D≤10^5,0≤S≤15,0≤ap,dp,mp≤10^4,1≤hp≤10^9)$ 怪物的属性由二进制表示，如果有先攻属性，那么S增加1，魔攻增加2，二连击增加4，模仿增加8。 接下来一行一个整数k，表示有k条规则。接下来k行，每行两个正整数$u,v(1≤u&lt;v≤n)$，表示怪u必须在怪v之前杀死。 输出格式 对于每组数据输出一行，表示杀完所有的怪剩下的最多血量。如果无法清完所有怪，那么输出−1。 样例: 样例输入:120 2 2 0102 2 0 0 2 0 0 8018 8 0 0 0 0 0 2040 6 1 0 2 0 0 4042 7 3 0 1 0 0 4010 10 5 0 0 2 0 4025 5 0 0 0 0 0 2035 4 1 0 0 1 0 2060 7 2 0 1 1 0 4032 8 2 0 0 0 0 60160 15 0 0 0 0 0 091 22 31 44 51 66 76 87 94 10 样例输出:-1 限制与规定： 对于 20% 的数据，有 1≤n≤5,k=0，所有怪物没有特殊属性。 对于 40% 的数据，有 1≤n≤8,k=0，所有怪物没有特殊属性。 对于另外 20% 的数据，有 1≤n≤14,k≤100，所有怪物没有特殊属性。 对于另外 20% 的数据，有 1≤n≤8,k≤100。 对于 100% 的数据，有 1≤n≤14,k≤100,T≤10。 时间限制：10s 空间限制：512MB 解释： 关于魔防可以认为打完一个怪总伤害会减去魔防的值，也可以理解成每次打怪前你有一个血量为魔防值的护盾，怪物会优先扣护盾的血量。 比如说你的攻击是15，防御是5，魔防是7，怪物血量是20，攻击是20，防御是5，没有特殊属性。 那么你可以在2轮杀死怪物，怪物会攻击你1轮。你打这个怪受到的伤害为max(15−7,0)。 你每次可以选择打一个不违反限制的怪或者吃一个不违反限制的宝石。 样例1只要按顺序打怪并且吃宝石即可。 两个人轮流攻击，我们记A为勇士，B为怪物。 那么先攻的攻击顺序为BABABA… 二连击的攻击顺序为ABBABBABB… 吐槽&amp;题解： 古老的魔塔游戏2333 跟10k大模拟没有毛线关系（不愧是传说中的毒瘤出题人） 三进制状压。。。（看到数据范围想到二进制状压emmm） 第i位为0表示没打第i位怪，1表示打了怪没吃水晶（Q：为什么会不吃水晶呢？A：因为有模仿怪呀！），2表示打了怪吃了水晶。 因为答案是要求最大血量，那么我们就用f[i]来表示i这个状态最大的血量，然后预处理出各个状态的攻击，防御，魔防。 转移的话，第i只怪的位置如果要从0-&gt;1，则先判断在这只怪之前必打的怪打了没有，然后如果S（S为以当前状态k的属性打这个怪后的血量）大于要更新的状态$f[k+3^{i-1}]$，那就更新。 而如果要从1-&gt;2，则只要$f[k+3^{i-1}]=max(f[k+3^{i-1}],f[k]+hp[i])$,因为其它属性已经预处理好了。 至于打怪操作和怪的特殊属性，大力模拟就好了。。。 贴个代码。。。暴力都打不来的我真是太弱了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//三进制状压 0-&gt;没打 1-&gt;打了没吃 2-&gt;打了吃了 #include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#define ll long long#define maxn 15#define maxx 4783970using namespace std;int A,D;ll H;int N,M,T,K;int h[maxn],a[maxn],d[maxn],s[maxn];int ph[maxn],pa[maxn],pd[maxn],pm[maxn];int mi[maxn];int fa[maxx],fd[maxx],fm[maxx];ll f[maxx];vector&lt;int&gt;Pre[maxn];void ins(int a,int b)&#123; Pre[a].push_back(b);&#125;ll beat(ll H,int A,int D,int M,int h,int a,int d,int s)&#123; if(s&amp;8)a=A,d=D; if(s&amp;2)D=0; int o=1+((s&gt;&gt;2)&amp;1); int X=max(0,a-D)*o;//怪伤 int x=max(0,A-d);//人伤 if(x==0)return 0; ll S=1ll*((h-1)/x+1-(~s&amp;1))*X; if(S&gt;H+M)return 0; if(S&gt;M)H=H-(S-M); return H;&#125;int main()&#123; mi[0]=1; for(int i=1;i&lt;15;++i)mi[i]=mi[i-1]+(mi[i-1]&lt;&lt;1); scanf("%d",&amp;T); while(T--)&#123; scanf("%lld%d%d%d",&amp;H,&amp;A,&amp;D,&amp;M); scanf("%d",&amp;N); // for(int i=1;i&lt;=N;++i)Pre[i].clear(); memset(f,0,sizeof(f)); f[0]=H; // for(int i=1;i&lt;=N;++i)&#123; scanf("%d%d%d%d",&amp;h[i],&amp;a[i],&amp;d[i],&amp;s[i]); scanf("%d%d%d%d",&amp;pa[i],&amp;pd[i],&amp;pm[i],&amp;ph[i]); &#125; scanf("%d",&amp;K); int u,v; for(int i=1;i&lt;=K;++i)&#123; scanf("%d%d",&amp;u,&amp;v); ins(v,u);//*** &#125; int tot=mi[N]-1; for(int k=0;k&lt;=tot;++k)&#123; fa[k]=A,fd[k]=D,fm[k]=M; for(int i=1;i&lt;=N;++i)&#123; if(k/mi[i-1]%3==2)&#123; fa[k]+=pa[i],fd[k]+=pd[i],fm[k]+=pm[i]; &#125; &#125; &#125; for(int k=0;k&lt;=tot;++k)&#123; if(!f[k])continue; for(int i=1;i&lt;=N;++i)&#123; if(k/mi[i-1]%3==0)&#123; bool bz=0; for(int j=0;j&lt;Pre[i].size();++j)&#123; if(k/mi[Pre[i][j]-1]%3==0)&#123; bz=1; break; &#125; &#125; if(bz)continue; ll S=beat(f[k],fa[k],fd[k],fm[k],h[i],a[i],d[i],s[i]); if(S&gt;0)f[k+mi[i-1]]=max(f[k+mi[i-1]],S); &#125; else&#123; if(k/mi[i-1]%3==1)&#123; f[k+mi[i-1]]=max(f[k+mi[i-1]],f[k]+ph[i]); &#125; &#125; &#125; &#125; if(f[tot]==0)printf("-1\n"); else printf("%lld\n",f[tot]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[POJ3764--The xor-longest Path]]></title>
    <url>%2F2018%2F08%2F03%2FPOJ3764%2F</url>
    <content type="text"><![CDATA[传送门：POJ3764—The xor-longest Path题目大意:在一颗带权的树上，求任意两点间路径上各边权值异或和的最大值。题目解法：设dis(u,v)为u,v间路径上各边权值异或和。显然dis(u,v)==dis(root,u)^dis(root,v),所以问题转换为求任意两个点i,j到root的路径上各边权值异或和最大。于是我们用dfs预处理，把每个dis(root,i)丢进一个二进制trie中。那每丢一个dis(root,i)，显然要在trie中找能使尽量多的二进制位与dis(root,i)相反，这样才能使这两个的异或和最大，这其实就是个贪心。真相は一つしかない: 正解就是trie+贪心（逃嗯♂~~~代码实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#define ll long long#define maxn 100005using namespace std;int N;int _last[maxn],_next[maxn&lt;&lt;1],_end[maxn&lt;&lt;1],_len[maxn&lt;&lt;1];int val[maxn];int o;int tot;void ins(int a,int b,int c)&#123; _end[++o]=b; _next[o]=_last[a]; _last[a]=o; _len[o]=c;&#125;void inss(int a,int b,int c)&#123; ins(a,b,c); ins(b,a,c);&#125;struct node&#123; int son[2]; void init()&#123; son[0]=son[1]=0; &#125;&#125;;node tri[4000005];void dfs(int u,int fa)&#123; for(int i=_last[u];i;i=_next[i])&#123; int v=_end[i]; if(v==fa)continue; val[v]=val[u]^_len[i]; dfs(v,u); &#125;&#125;void add(int x)&#123; int p=0; int o=0; for(int i=30;i&gt;=0;--i)&#123; if(x&amp;(1&lt;&lt;i))o=1; else o=0; if(!tri[p].son[o])&#123; tri[p].son[o]=++tot; tri[tot].init(); &#125; p=tri[p].son[o]; &#125;&#125;int gs(int x)&#123; int num=0,p=0,o=0; for(int i=30;i&gt;=0;--i)&#123; if(x&amp;(1&lt;&lt;i))o=0; else o=1; if(tri[p].son[o])&#123; num|=(1&lt;&lt;i); p=tri[p].son[o]; &#125; else p=tri[p].son[o^1]; &#125; return num;&#125;int main()&#123; while(scanf("%d",&amp;N)!=EOF)&#123; for(int i=1;i&lt;=o;++i)_last[i]=0; o=0; tot=0; tri[tot].init(); val[1]=0; int u,v,w; for(int i=1;i&lt;N;++i) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); ++u; ++v; inss(u,v,w); &#125; dfs(1,0); int ans=0; for(int i=1;i&lt;=N;++i)&#123; ans=max(ans,gs(val[i])); add(val[i]); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello world!!!]]></title>
    <url>%2F2018%2F07%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[啊♂，终于搞好了,可以搞事了（嘿嘿嘿）]]></content>
  </entry>
</search>
