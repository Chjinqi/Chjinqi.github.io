<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[铁路运输]]></title>
    <url>%2F2018%2F10%2F31%2F%E9%93%81%E8%B7%AF%E8%BF%90%E8%BE%93%2F</url>
    <content type="text"><![CDATA[铁路运费(train.pas/c/cpp)吐槽：今天摸你赛好颓啊。。。【问题描述】 CSSYZ 国有 N 个城市，依次编号为 1, 2, …, N。城市 1 是 CSSYZ 国的首都。该国的铁路公司只有1家，由FYT垄断经营，FYT公司运营着M条路线。路线被编号为1, 2, …M，第 i 条线路(1&lt;=i&lt;=M)双向连接着城市 Ui和城市 Vi。城市间的移动方式只有铁路。任意两个城市之间都能通过若干条铁路互通，即任意两个城市之间，直接连接的路线最多只有 1 条；对于任一城市，从该市总是可以通过若干条路线到达城市 1。 现在所有路线的运费都是 1 元。陷于经营困境的 FYT 计划在今后 Q 年间提高若干条路线的运费。在这个计划里，第 j 年(1&lt;=j&lt;=Q)的年初将把路线 Rj的运费从 1 元提升到2 元。被提价过一次的路线的运费将一直是 2 元，不会再次提价。此外，FYT 的铁路公司每年还会调查每个城市的市民的满意度。计划开始前，每个城市的市民都表示满意，但提价之后，可能会出现表示不满的市民。每年的满意度调查都在当年的提价完成之后进行。所以进行第 j 年(1&lt;=j&lt;=Q)的满意度调查时，路线 R1, R2, …, Rj的运费提升已经完成，此外的路线还没有被提价。第 j 年的满意度调查里，如果城市 k(2&lt;=k&lt;=N)的市民从城市 k 到首都城市 1 的费用的最小值比计划开始前的最小费用要高，则会对铁路公司表示不满。 如果路线经过多条铁路，费用是各条路线的运费的和。城市 1 的市民不会对铁路公司表示不满。另外请注意，提价后获得最小费用要使用的路线可能跟计划开始前的不一样。在整个计划开始之前，对于今后 Q 年间市民的满意度调查，FYT 希望计算存在不满市民的城市个数。请写出一个程序，给定 CSSYZ 国的铁路路线信息和提价计划，输出每次满意度调查里存在不满市民的城市个数。 【输入】 第一行为 3 个用空格隔开的整数 N, M, Q。N 为城市个数，M 为路线条数，Q 为提价计划的执行年数。 接下来 M 行中第 i 行(1&lt;=i&lt;=M)为两个用空格隔开的整数 Ui, Vi，表示第 i 条路线连接着城市 Ui和 Vi。 接下来 Q 行中第 j 行(1&lt;=j&lt;=Q)为整数 Rj，表示计划的第 j 年将提升路线 Rj的运费。 【输出】输出 Q 行，第 j 行(1&lt;=j&lt;=Q)表示第 j 年的满意度调查中存在不满市民的城市个数。 【输入输出样例1】1234567891011125 6 51 21 34 23 22 55 352413 1234502244 【输入输出样例2】123456789101112134 6 61 21 31 42 32 43 4142536 123456112233 【数据范围】 25%的数据满足：N&lt;=100，M&lt;=4 950，Q&lt;=30； 50%的数据满足：Q&lt;=30；75%的数据满足：输出结果里出现的不同数最多50种； 100%的数据满足：2 ≦ N ≦ 100 000，1 ≦ Q ≦ M ≦ 200 000，1 ≦ Ui ≦ N， 1 ≦ Vi ≦ N，Ui != Vi ，1 ≦ Rj ≦ M，Rj != Rk (1 ≦ j &lt; k ≦ Q） 题解。。。（膜拜hdhd）由于当时我在颓。。。没仔细想啊我太弱了把原图改为只有1到各点为最短路的图，于是改边权可变为删边（具体原理，用心体会）于是最后查询时，若这条边的点入度为零就删点，因为此时这个点到1不是最短路，所以ans++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//丢个代码溜了呀，再次膜拜hdhd#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;queue&gt;#define ll long long#define inf 0x3f3f3f3f#define maxn 100005using namespace std;int N,M,Q;int Last[maxn],Next[maxn&lt;&lt;2],End[maxn&lt;&lt;2],o=1;int dis[maxn];int belong[maxn&lt;&lt;1],id[maxn&lt;&lt;1];int du[maxn];vector&lt;int&gt;G[maxn];bool del[maxn];int ans;queue&lt;int&gt;Qu;void ins(int a,int b)&#123; End[++o]=b; Next[o]=Last[a]; Last[a]=o;&#125;void inss(int a,int b)&#123; ins(a,b),ins(b,a);&#125;void Del(int u)&#123; if(del[u])return; del[u]=1; ans++; for(int i=0,v;i&lt;G[u].size();++i)&#123; v=G[u][i]; if(v&lt;0)continue; --du[v]; G[u][i]=-1; if(!du[v])Del(v); &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;N,&amp;M,&amp;Q); int a,b; for(int i=1;i&lt;=M;++i)&#123; scanf("%d%d",&amp;a,&amp;b),inss(a,b); &#125; for(int i=2;i&lt;=N;++i)dis[i]=inf; Qu.push(1); while(Qu.size())&#123; int u=Qu.front(); Qu.pop(); for(int i=Last[u],v;i;i=Next[i])&#123; v=End[i]; if(dis[v]&gt;dis[u]+1)&#123; dis[v]=dis[u]+1; Qu.push(v); &#125; &#125; &#125; for(int u=1;u&lt;=N;++u)&#123; for(int i=Last[u],v;i;i=Next[i])&#123; v=End[i]; if(dis[v]==dis[u]+1)&#123; ++du[v]; belong[i&gt;&gt;1]=u; id[i&gt;&gt;1]=G[u].size(); G[u].push_back(v); &#125; &#125; &#125; int tmp; while(Q--)&#123; scanf("%d",&amp;tmp); if(!belong[tmp])&#123;//不在最短路中 printf("%d\n",ans); continue; &#125; int u=belong[tmp],v=G[u][id[tmp]]; if(v&lt;0)&#123;//边删了 printf("%d\n",ans); continue; &#125; G[u][id[tmp]]=-1; --du[v]; if(!du[v])Del(v);//若入度为零就删点，此时这个点到1不是最短路即ans++ printf("%d\n",ans); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[同余系BFS]]></title>
    <url>%2F2018%2F10%2F29%2F%E5%90%8C%E4%BD%99%E7%B1%BBBFS%2F</url>
    <content type="text"><![CDATA[题目链接：P3403 跳楼机题目意思：给定x,y,z,H,求x,y,z由加法能得到的H以内的数的个数。体节 ：乍一看是个数论，心里一想，不对~~于是蒟蒻只能去学了一发同余系BFS（%%%Newuser大佬）那这题就成了模板啦！设x为x,y,z最小的，在模x意义下，由i-&gt;(i+y)%x，权值为y；由i-&gt;(i+z)%x，权值为z。最后跑一遍最短路或BFS，求出dis[i],那么dis[i]+k*x都能取到，于是此题得解。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#define ll long long#define maxn 100005using namespace std;ll H;int P[4];ll dis[maxn];bool vis[maxn];int Last[maxn],Next[maxn&lt;&lt;1],End[maxn&lt;&lt;1],Len[maxn&lt;&lt;1],o;void ins(int a,int b,int c)&#123; End[++o]=b; Next[o]=Last[a]; Last[a]=o; Len[o]=c;&#125;void spfa(int x)&#123; queue&lt;int&gt;Q; memset(dis,0x3f,sizeof(dis)); dis[x]=1; vis[x]=1; Q.push(x); while(Q.size())&#123; int u=Q.front(); Q.pop(); vis[u]=0; for(int i=Last[u],v;i;i=Next[i])&#123; v=End[i]; if(dis[u]+Len[i]&lt;dis[v])&#123; dis[v]=dis[u]+Len[i]; if(!vis[v])&#123; vis[v]=1; Q.push(v); &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%lld%d%d%d",&amp;H,&amp;P[1],&amp;P[2],&amp;P[3]); sort(P+1,P+3); if(P[1]==1)&#123; printf("%lld",H); return 0; &#125; for(int i=0;i&lt;P[1];++i)&#123; int pos2=(i+P[2])%P[1]; int pos3=(i+P[3])%P[1]; ins(i,pos2,P[2]),ins(i,pos3,P[3]); &#125; spfa(1); ll ans=0; for(int i=0;i&lt;P[1];++i)&#123; if(dis[i]&lt;=H)&#123; ans+=(H-dis[i])/P[1]+1; &#125; &#125; printf("%lld",ans); return 0;&#125; NOIP来了，看似慌得一笔实际慌得一笔，只有%大佬们才能攒人品呢。 123while(1)&#123; if(%hdhd&amp;&amp;%PHD&amp;&amp;%Newuser&amp;&amp;%Washington)RP++;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ZROJ2018D6T1--萌新拆塔]]></title>
    <url>%2F2018%2F08%2F10%2FZROJ2018D6T1-%E8%90%8C%E6%96%B0%E6%8B%86%E5%A1%94%2F</url>
    <content type="text"><![CDATA[传送门：ZROJ2018D6T1—萌新拆塔注：杜老师出题~~~题面： 作为一场自闭模拟赛，需要一道10k模拟加玄学剪枝题。 在魔塔这个游戏中，勇士有四个数值，血量，攻击，防御和魔防。怪物也有三个数值，血量，攻击和防御。勇士和怪物攻击方式一般是这样的，双方轮流攻击，每回合造成自己攻击减去对方防御的伤害，如果自己的攻击比对方的防御低，那么无法对对方造成伤害。如果怪物血量变得小于等于0，那么怪物死亡，勇士获胜。如果勇士的攻击不超过怪物的防御，那么无法战斗。在一场战斗后，如果怪兽造成的总伤害超过了自己的魔防，那么消耗的血量为总伤害减去自己的魔防值，否则伤害为0。勇士必须保证战斗之后剩余的血量大于0。 一般来说，都是勇士先攻击。但是怪物有一些特殊属性： 先攻：第一个回合由怪物先攻击。 魔攻：怪物会无视勇士的防御，你可以认为在战斗的时候勇士的防御为0。 二连击：怪物每回合攻击两次。 模仿：怪物的攻防与勇士的攻防相同。 这四个特殊属性都是可以任意叠加的。 这个魔塔里面有n个怪，每个怪后面都守着一个宝石，每个宝石都能对血量，攻击，防御和魔防这些数值有所增益。同时打怪之间有一些先后顺序，比如说如果怪v被怪u挡住了，那么我们只能先打u再打v。所以我们会有k条规则，表示u这个怪必须在v之前打。 你可以需要按一定顺序去清怪和吃宝石，吃宝石之前要求守着这个宝石的怪被杀死。 请问杀完所有的怪剩下的最多能剩多少血量。 输入格式: 第一行一个整数T，表示数据组数。 每组数据第一行四个整数，表示$h,a,d,m$，表示勇士的初始血量，攻击，防御与魔防。$(1≤h≤10^9,1≤a,d≤10^5,0≤m≤10^5)$ 接下来一行一个数字n，表示怪的数量。 接下来n行，每行八个数字，表示$H,A,D,S,ap,dp,mp,hp$，表示怪物的血量，攻击，防御，属性，以及怪物守的宝石能增加的攻击，防御，魔防和血量。 $(1≤H,A,D≤10^5,0≤S≤15,0≤ap,dp,mp≤10^4,1≤hp≤10^9)$ 怪物的属性由二进制表示，如果有先攻属性，那么S增加1，魔攻增加2，二连击增加4，模仿增加8。 接下来一行一个整数k，表示有k条规则。接下来k行，每行两个正整数$u,v(1≤u&lt;v≤n)$，表示怪u必须在怪v之前杀死。 输出格式 对于每组数据输出一行，表示杀完所有的怪剩下的最多血量。如果无法清完所有怪，那么输出−1。 样例: 样例输入:120 2 2 0102 2 0 0 2 0 0 8018 8 0 0 0 0 0 2040 6 1 0 2 0 0 4042 7 3 0 1 0 0 4010 10 5 0 0 2 0 4025 5 0 0 0 0 0 2035 4 1 0 0 1 0 2060 7 2 0 1 1 0 4032 8 2 0 0 0 0 60160 15 0 0 0 0 0 091 22 31 44 51 66 76 87 94 10 样例输出:-1 限制与规定： 对于 20% 的数据，有 1≤n≤5,k=0，所有怪物没有特殊属性。 对于 40% 的数据，有 1≤n≤8,k=0，所有怪物没有特殊属性。 对于另外 20% 的数据，有 1≤n≤14,k≤100，所有怪物没有特殊属性。 对于另外 20% 的数据，有 1≤n≤8,k≤100。 对于 100% 的数据，有 1≤n≤14,k≤100,T≤10。 时间限制：10s 空间限制：512MB 解释： 关于魔防可以认为打完一个怪总伤害会减去魔防的值，也可以理解成每次打怪前你有一个血量为魔防值的护盾，怪物会优先扣护盾的血量。 比如说你的攻击是15，防御是5，魔防是7，怪物血量是20，攻击是20，防御是5，没有特殊属性。 那么你可以在2轮杀死怪物，怪物会攻击你1轮。你打这个怪受到的伤害为max(15−7,0)。 你每次可以选择打一个不违反限制的怪或者吃一个不违反限制的宝石。 样例1只要按顺序打怪并且吃宝石即可。 两个人轮流攻击，我们记A为勇士，B为怪物。 那么先攻的攻击顺序为BABABA… 二连击的攻击顺序为ABBABBABB… 吐槽&amp;题解： 古老的魔塔游戏2333 跟10k大模拟没有毛线关系（不愧是传说中的毒瘤出题人） 三进制状压。。。（看到数据范围想到二进制状压emmm） 第i位为0表示没打第i位怪，1表示打了怪没吃水晶（Q：为什么会不吃水晶呢？A：因为有模仿怪呀！），2表示打了怪吃了水晶。 因为答案是要求最大血量，那么我们就用f[i]来表示i这个状态最大的血量，然后预处理出各个状态的攻击，防御，魔防。 转移的话，第i只怪的位置如果要从0-&gt;1，则先判断在这只怪之前必打的怪打了没有，然后如果S（S为以当前状态k的属性打这个怪后的血量）大于要更新的状态$f[k+3^{i-1}]$，那就更新。 而如果要从1-&gt;2，则只要$f[k+3^{i-1}]=max(f[k+3^{i-1}],f[k]+hp[i])$,因为其它属性已经预处理好了。 至于打怪操作和怪的特殊属性，大力模拟就好了。。。 贴个代码。。。暴力都打不来的我真是太弱了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//三进制状压 0-&gt;没打 1-&gt;打了没吃 2-&gt;打了吃了 #include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#define ll long long#define maxn 15#define maxx 4783970using namespace std;int A,D;ll H;int N,M,T,K;int h[maxn],a[maxn],d[maxn],s[maxn];int ph[maxn],pa[maxn],pd[maxn],pm[maxn];int mi[maxn];int fa[maxx],fd[maxx],fm[maxx];ll f[maxx];vector&lt;int&gt;Pre[maxn];void ins(int a,int b)&#123; Pre[a].push_back(b);&#125;ll beat(ll H,int A,int D,int M,int h,int a,int d,int s)&#123; if(s&amp;8)a=A,d=D; if(s&amp;2)D=0; int o=1+((s&gt;&gt;2)&amp;1); int X=max(0,a-D)*o;//怪伤 int x=max(0,A-d);//人伤 if(x==0)return 0; ll S=1ll*((h-1)/x+1-(~s&amp;1))*X; if(S&gt;H+M)return 0; if(S&gt;M)H=H-(S-M); return H;&#125;int main()&#123; mi[0]=1; for(int i=1;i&lt;15;++i)mi[i]=mi[i-1]+(mi[i-1]&lt;&lt;1); scanf("%d",&amp;T); while(T--)&#123; scanf("%lld%d%d%d",&amp;H,&amp;A,&amp;D,&amp;M); scanf("%d",&amp;N); // for(int i=1;i&lt;=N;++i)Pre[i].clear(); memset(f,0,sizeof(f)); f[0]=H; // for(int i=1;i&lt;=N;++i)&#123; scanf("%d%d%d%d",&amp;h[i],&amp;a[i],&amp;d[i],&amp;s[i]); scanf("%d%d%d%d",&amp;pa[i],&amp;pd[i],&amp;pm[i],&amp;ph[i]); &#125; scanf("%d",&amp;K); int u,v; for(int i=1;i&lt;=K;++i)&#123; scanf("%d%d",&amp;u,&amp;v); ins(v,u);//*** &#125; int tot=mi[N]-1; for(int k=0;k&lt;=tot;++k)&#123; fa[k]=A,fd[k]=D,fm[k]=M; for(int i=1;i&lt;=N;++i)&#123; if(k/mi[i-1]%3==2)&#123; fa[k]+=pa[i],fd[k]+=pd[i],fm[k]+=pm[i]; &#125; &#125; &#125; for(int k=0;k&lt;=tot;++k)&#123; if(!f[k])continue; for(int i=1;i&lt;=N;++i)&#123; if(k/mi[i-1]%3==0)&#123; bool bz=0; for(int j=0;j&lt;Pre[i].size();++j)&#123; if(k/mi[Pre[i][j]-1]%3==0)&#123; bz=1; break; &#125; &#125; if(bz)continue; ll S=beat(f[k],fa[k],fd[k],fm[k],h[i],a[i],d[i],s[i]); if(S&gt;0)f[k+mi[i-1]]=max(f[k+mi[i-1]],S); &#125; else&#123; if(k/mi[i-1]%3==1)&#123; f[k+mi[i-1]]=max(f[k+mi[i-1]],f[k]+ph[i]); &#125; &#125; &#125; &#125; if(f[tot]==0)printf("-1\n"); else printf("%lld\n",f[tot]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[POJ3764--The xor-longest Path]]></title>
    <url>%2F2018%2F08%2F03%2FPOJ3764%2F</url>
    <content type="text"><![CDATA[传送门：POJ3764—The xor-longest Path题目大意:在一颗带权的树上，求任意两点间路径上各边权值异或和的最大值。题目解法：设dis(u,v)为u,v间路径上各边权值异或和。显然dis(u,v)==dis(root,u)^dis(root,v),所以问题转换为求任意两个点i,j到root的路径上各边权值异或和最大。于是我们用dfs预处理，把每个dis(root,i)丢进一个二进制trie中。那每丢一个dis(root,i)，显然要在trie中找能使尽量多的二进制位与dis(root,i)相反，这样才能使这两个的异或和最大，这其实就是个贪心。真相は一つしかない: 正解就是trie+贪心（逃嗯♂~~~代码实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#define ll long long#define maxn 100005using namespace std;int N;int _last[maxn],_next[maxn&lt;&lt;1],_end[maxn&lt;&lt;1],_len[maxn&lt;&lt;1];int val[maxn];int o;int tot;void ins(int a,int b,int c)&#123; _end[++o]=b; _next[o]=_last[a]; _last[a]=o; _len[o]=c;&#125;void inss(int a,int b,int c)&#123; ins(a,b,c); ins(b,a,c);&#125;struct node&#123; int son[2]; void init()&#123; son[0]=son[1]=0; &#125;&#125;;node tri[4000005];void dfs(int u,int fa)&#123; for(int i=_last[u];i;i=_next[i])&#123; int v=_end[i]; if(v==fa)continue; val[v]=val[u]^_len[i]; dfs(v,u); &#125;&#125;void add(int x)&#123; int p=0; int o=0; for(int i=30;i&gt;=0;--i)&#123; if(x&amp;(1&lt;&lt;i))o=1; else o=0; if(!tri[p].son[o])&#123; tri[p].son[o]=++tot; tri[tot].init(); &#125; p=tri[p].son[o]; &#125;&#125;int gs(int x)&#123; int num=0,p=0,o=0; for(int i=30;i&gt;=0;--i)&#123; if(x&amp;(1&lt;&lt;i))o=0; else o=1; if(tri[p].son[o])&#123; num|=(1&lt;&lt;i); p=tri[p].son[o]; &#125; else p=tri[p].son[o^1]; &#125; return num;&#125;int main()&#123; while(scanf("%d",&amp;N)!=EOF)&#123; for(int i=1;i&lt;=o;++i)_last[i]=0; o=0; tot=0; tri[tot].init(); val[1]=0; int u,v,w; for(int i=1;i&lt;N;++i) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); ++u; ++v; inss(u,v,w); &#125; dfs(1,0); int ans=0; for(int i=1;i&lt;=N;++i)&#123; ans=max(ans,gs(val[i])); add(val[i]); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello world!!!]]></title>
    <url>%2F2018%2F07%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[啊♂，终于搞好了,可以搞事了（嘿嘿嘿）]]></content>
  </entry>
</search>
